{"/home/travis/build/npmtest/node-npmtest-classifier/test.js":"/* istanbul instrument in package npmtest_classifier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-classifier/lib.npmtest_classifier.js":"/* istanbul instrument in package npmtest_classifier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_classifier = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_classifier = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-classifier/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-classifier && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_classifier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_classifier\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_classifier.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_classifier.rollup.js'] =\n            local.assetsDict['/assets.npmtest_classifier.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_classifier.__dirname + '/lib.npmtest_classifier.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/lib/bayesian.js":"var _ = require(\"underscore\")._;\n\nvar Bayesian = function(options) {\n  options = options || {}\n  this.thresholds = options.thresholds || {};\n  this.default = options.default || 'unclassified';\n  this.weight = options.weight || 1;\n  this.assumed = options.assumed || 0.5;\n\n  var backend = options.backend || { type: 'memory' };\n  switch(backend.type.toLowerCase()) {\n    case 'redis':\n      this.backend = new (require(\"./backends/redis\").RedisBackend)(backend.options);\n      break;\n    case 'localstorage':\n      this.backend = new (require(\"./backends/localStorage\")\n                     .LocalStorageBackend)(backend.options);\n      break;\n    default:\n      this.backend = new (require(\"./backends/memory\").MemoryBackend)();\n  }\n}\n\nBayesian.prototype = {\n  getCats : function(callback) {\n    return this.backend.getCats(callback);\n  },\n\n  getWordCounts : function(words, cats, callback) {\n    return this.backend.getWordCounts(words, cats, callback);\n  },\n\n  incDocCounts : function(docs, callback) {\n    // accumulate all the pending increments\n    var wordIncs = {};\n    var catIncs = {};\n    docs.forEach(function(doc) {\n      var cat = doc.cat;\n      catIncs[cat] = catIncs[cat] ? catIncs[cat] + 1 : 1;\n\n      var words = this.getWords(doc.doc);\n      words.forEach(function(word) {\n        wordIncs[word] = wordIncs[word] || {};\n        wordIncs[word][cat] = wordIncs[word][cat] ? wordIncs[word][cat] + 1 : 1;\n      }, this);\n    }, this);\n\n    return this.backend.incCounts(catIncs, wordIncs, callback);\n  },\n\n  setThresholds : function(thresholds) {\n    this.thresholds = thresholds;\n  },\n\n  getWords : function(doc) {\n    if (_(doc).isArray()) {\n      return doc;\n    }\n    var words = doc.split(/\\W+/);\n    return _(words).uniq();\n  },\n\n  train : function(doc, cat, callback) {\n    this.incDocCounts([{doc: doc, cat: cat}], function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n    });\n  },\n\n  trainAll : function(data, callback) {\n    data = data.map(function(item) {\n      return {doc: item.input, cat: item.output};\n    });\n    this.incDocCounts(data, function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n    });\n  },\n\n  wordProb : function(word, cat, cats, counts) {\n    // times word appears in a doc in this cat / docs in this cat\n    var prob = (counts[cat] || 0) / cats[cat];\n\n    // get weighted average with assumed so prob won't be extreme on rare words\n    var total = _(cats).reduce(function(sum, p, cat) {\n      return sum + (counts[cat] || 0);\n    }, 0, this);\n    return (this.weight * this.assumed + total * prob) / (this.weight + total);\n  },\n\n  getCatProbs : function(cats, words, counts) {\n    var numDocs = _(cats).reduce(function(sum, count) {\n      return sum + count;\n    }, 0);\n\n    var probs = {};\n    _(cats).each(function(catCount, cat) {\n      var catProb = (catCount || 0) / numDocs;\n\n      var docProb = _(words).reduce(function(prob, word) {\n        var wordCounts = counts[word] || {};\n        return prob * this.wordProb(word, cat, cats, wordCounts);\n      }, 1, this);\n\n      // the probability this doc is in this category\n      probs[cat] = catProb * docProb;\n    }, this);\n    return probs;\n  },\n\n  getProbs : function(doc, callback) {\n    var that = this;\n    this.getCats(function(cats) {\n      var words = that.getWords(doc);\n      that.getWordCounts(words, cats, function(counts) {\n        var probs = that.getCatProbs(cats, words, counts);\n        callback(probs);\n      });\n    });\n  },\n\n  getProbsSync : function(doc) {\n    var words = this.getWords(doc);\n    var cats = this.getCats();\n    var counts = this.getWordCounts(words, cats);\n    return this.getCatProbs(cats, words, counts);\n  },\n\n  bestMatch : function(probs) {\n    var max = _(probs).reduce(function(max, prob, cat) {\n      return max.prob > prob ? max : {cat: cat, prob: prob};\n    }, {prob: 0});\n\n    var category = max.cat || this.default;\n    var threshold = this.thresholds[max.cat] || 1;\n\n    _(probs).map(function(prob, cat) {\n     if (!(cat == max.cat) && prob * threshold > max.prob) {\n       category = this.default; // not greater than other category by enough\n     }\n    }, this);\n\n    return category;\n  },\n\n  classify : function(doc, callback) {\n    if (!this.backend.async) {\n      return this.classifySync(doc);\n    }\n\n    var that = this;\n    this.getProbs(doc, function(probs) {\n      callback(that.bestMatch(probs));\n    });\n  },\n\n  classifySync : function(doc) {\n    var probs = this.getProbsSync(doc);\n    return this.bestMatch(probs);\n  },\n\n  test : function(data) {\n    // misclassification error\n    var error = 0;\n    data.forEach(function(datum) {\n      var output = this.classify(datum.input);\n      error += output == datum.output ? 0 : 1;\n    }, this);\n    return error / data.length;\n  },\n\n  toJSON : function(callback) {\n    return this.backend.toJSON(callback);\n  },\n\n  fromJSON : function(json, callback) {\n    this.backend.fromJSON(json, callback);\n    return this;\n  }\n}\n\nexports.Bayesian = Bayesian;\n","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/classifier-b.js":"(function(){var global = this;function debug(){return debug};function require(p, parent){ var path = require.resolve(p) , mod = require.modules[path]; if (!mod) throw new Error('failed to require \"' + p + '\" from ' + parent); if (!mod.exports) { mod.exports = {}; mod.call(mod.exports, mod, mod.exports, require.relative(path), global); } return mod.exports;}require.modules = {};require.resolve = function(path){ var orig = path , reg = path + '.js' , index = path + '/index.js'; return require.modules[reg] && reg || require.modules[index] && index || orig;};require.register = function(path, fn){ require.modules[path] = fn;};require.relative = function(parent) { return function(p){ if ('debug' == p) return debug; if ('.' != p.charAt(0)) return require(p); var path = parent.split('/') , segs = p.split('/'); path.pop(); for (var i = 0; i < segs.length; i++) { var seg = segs[i]; if ('..' == seg) path.pop(); else if ('.' != seg) path.push(seg); } return require(path.join('/'), parent); };};require.register(\"lib/backends/localStorage.js\", function(module, exports, require, global){\nvar _ = require(\"underscore\")._;\n\nvar LocalStorageBackend = function(options) {\n  var options = options || {};\n  var name = options.name || Math.floor(Math.random() * 100000);\n\n  this.prefix = 'classifier.bayesian.' + name;\n\n  if (options.testing) {\n    this.storage = {};\n  }\n  else {\n    this.storage = localStorage;\n  }\n\n  this.storage[this.prefix + '.cats'] = '{}';\n}\n\nLocalStorageBackend.prototype = {\n  async : false,\n\n  getCats : function() {\n    return JSON.parse(this.storage[this.prefix + '.cats']);\n  },\n\n  setCats : function(cats) {\n    this.storage[this.prefix + '.cats'] = JSON.stringify(cats);\n  },\n\n  getWordCount : function(word) {\n    return JSON.parse(this.storage[this.prefix + '.words.' + word] || '{}');\n  },\n\n  setWordCount : function(word, counts) {\n    this.storage[this.prefix + '.words.' + word] = JSON.stringify(counts);\n  },\n\n  getWordCounts : function(words) {\n    var counts = {};\n    words.forEach(function(word) {\n      counts[word] = this.getWordCount(word);\n    }, this);\n    return counts;\n  },\n\n  incCounts : function(catIncs, wordIncs) {\n    var cats = this.getCats();\n    _(catIncs).each(function(inc, cat) {\n      cats[cat] = cats[cat] + inc || inc;\n    }, this);\n    this.setCats(cats);\n\n    _(wordIncs).each(function(incs, word) {\n      var wordCounts = this.getWordCount(word);\n      _(incs).each(function(inc, cat) {\n        wordCounts[cat] = wordCounts[cat] + inc || inc;\n      }, this);\n      this.setWordCount(word, wordCounts);\n    }, this);\n  },\n\n  toJSON : function() {\n    var words = {};\n    var regex = new RegExp(\"^\" + this.prefix + \"\\.words\\.(.+)$\")\n    for (var item in this.storage) {\n      var match = regex.exec(item);\n      if (match) {\n        words[match[1]] = JSON.parse(this.storage[item]);\n      }\n    }\n    return {\n      cats: JSON.parse(this.storage[this.prefix + '.cats']),\n      words: words\n    };\n  },\n\n  fromJSON : function(json) {\n    this.incCounts(json.cats, json.words);\n  }\n}\n\nexports.LocalStorageBackend = LocalStorageBackend;\n});require.register(\"lib/backends/memory.js\", function(module, exports, require, global){\nvar _ = require(\"underscore\")._;\n\nvar MemoryBackend = function() {\n  this.catCounts = {};\n  this.wordCounts = {};\n}\n\nMemoryBackend.prototype = {\n  async : false,\n\n  incCounts : function(catIncs, wordIncs) {\n    _(catIncs).each(function(inc, cat) {\n      this.catCounts[cat] = this.catCounts[cat] + inc || inc;\n    }, this);\n\n    _(wordIncs).each(function(incs, word) {\n      this.wordCounts[word] = this.wordCounts[word] || {};\n      _(incs).each(function(inc, cat) {\n        this.wordCounts[word][cat] = this.wordCounts[word][cat] + inc || inc;\n      }, this);\n    }, this);\n  },\n\n  getCats : function() {\n    return this.catCounts;\n  },\n\n  getWordCounts : function(words, cats) {\n    return this.wordCounts;\n  },\n\n  toJSON : function() {\n    return {cats: this.catCounts, words: this.wordCounts}\n  },\n\n  fromJSON : function(json) {\n    this.catCounts = json.cats;\n    this.wordCounts = json.words;\n  }\n}\n\nexports.MemoryBackend = MemoryBackend;\n});require.register(\"lib/backends/redis.js\", function(module, exports, require, global){\nvar redis = require(\"redis\"),\n    _ = require(\"underscore\")._;\n\nvar RedisBackend = function(options) {\n  options = options || {};\n  var port = options.port || 6379;\n  var host = options.hostname || \"localhost\";\n  var opts = options.options || {};\n\n  this.client = function() {\n    var client = redis.createClient(port, host, opts);\n    if (options.error) {\n      client.on('error', options.error);\n    }\n    if (options.password) {\n      client.auth(options.password, options.error);\n    }\n    return client;\n  }\n\n  var name = options.name || Math.floor(Math.random() * 100000);\n  this.catsKey = 'classifier_bayes_cats_' + name;\n  this.wordsKey = 'classifier_bayes_words_' + name;\n\n  if (options.db) {\n    this.client().select(options.db);\n  }\n}\n\nRedisBackend.prototype = {\n  async : true,\n\n  key : function(word, cat) {\n    return word + \"____\" + cat; // flatten word count hash\n  },\n\n  pair : function(key) {\n    return /(.*)____(.*)/.exec(key).slice(1);\n  },\n\n  incCounts : function(catIncs, wordIncs, callback) {\n    // create new client for each call so we can close each time\n    var client = this.client();\n    var multi = client.multi(); // make multi so we can have one callback\n\n    _(catIncs).each(function(inc, cat) {\n      multi.hincrby(this.catsKey, cat, inc);\n    }, this);\n\n    _(wordIncs).each(function(wordCounts, word) {\n      _(wordCounts).each(function(inc, cat) {\n        multi.hincrby(this.wordsKey, this.key(word, cat), inc);\n      }, this);\n    }, this);\n\n    multi.exec(function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n      client.quit();\n    });\n  },\n\n  getCats : function(callback) {\n    var client = this.client();\n    client.hgetall(this.catsKey, function(err, cats) {\n      _(cats).each(function(val, cat) {\n        cats[cat] = parseInt(val);\n      });\n      callback(cats);\n      client.quit();\n    });\n  },\n\n  getWordCounts : function(words, cats, callback) {\n    var keys = _(words).reduce(function(keys, word) {\n       return keys.concat(_(cats).map(function(count, cat) {\n         return this.key(word, cat);\n       },this));\n    }, [], this);\n\n    var that = this;\n    var args = [this.wordsKey].concat(keys);\n    var client = this.client();\n\n    client.hmget(args, function(err, vals) {\n      var counts = {};\n      keys.map(function(key, i) {\n         var pair = that.pair(key);\n         var word = pair[0], cat = pair[1];\n         counts[word] = counts[word] ? counts[word] : {};\n         counts[word][cat] = parseInt(vals[i]) || 0;\n      });\n\n      callback(counts);\n      client.quit();\n    });\n  },\n\n  toJSON: function(callback) {\n    var that = this;\n    this.getCats(function(cats) {\n      var client = that.client();\n\n      client.hgetall(that.wordsKey, function(err, wordCounts) {\n        var words = {};\n        for (var key in wordCounts) {\n          var pair = that.pair(key);\n          var word = pair[0], cat = pair[1];\n          words[word] = words[word] ? words[word] : {};\n          words[word][cat] = parseInt(wordCounts[key]) || 0;\n        }\n\n        callback({cats: cats, words: words});\n        client.quit();\n      });\n    });\n  },\n\n  fromJSON: function(json, callback) {\n    this.incCounts(json.cats, json.words, callback);\n  }\n}\n\nexports.RedisBackend = RedisBackend;\n\n});require.register(\"lib/bayesian.js\", function(module, exports, require, global){\nvar _ = require(\"underscore\")._;\n\nvar Bayesian = function(options) {\n  options = options || {}\n  this.thresholds = options.thresholds || {};\n  this.default = options.default || 'unclassified';\n  this.weight = options.weight || 1;\n  this.assumed = options.assumed || 0.5;\n\n  var backend = options.backend || { type: 'memory' };\n  switch(backend.type.toLowerCase()) {\n    case 'redis':\n      this.backend = new (require(\"./backends/redis\").RedisBackend)(backend.options);\n      break;\n    case 'localstorage':\n      this.backend = new (require(\"./backends/localStorage\")\n                     .LocalStorageBackend)(backend.options);\n      break;\n    default:\n      this.backend = new (require(\"./backends/memory\").MemoryBackend)();\n  }\n}\n\nBayesian.prototype = {\n  getCats : function(callback) {\n    return this.backend.getCats(callback);\n  },\n\n  getWordCounts : function(words, cats, callback) {\n    return this.backend.getWordCounts(words, cats, callback);\n  },\n\n  incDocCounts : function(docs, callback) {\n    // accumulate all the pending increments\n    var wordIncs = {};\n    var catIncs = {};\n    docs.forEach(function(doc) {\n      var cat = doc.cat;\n      catIncs[cat] = catIncs[cat] ? catIncs[cat] + 1 : 1;\n\n      var words = this.getWords(doc.doc);\n      words.forEach(function(word) {\n        wordIncs[word] = wordIncs[word] || {};\n        wordIncs[word][cat] = wordIncs[word][cat] ? wordIncs[word][cat] + 1 : 1;\n      }, this);\n    }, this);\n\n    return this.backend.incCounts(catIncs, wordIncs, callback);\n  },\n\n  setThresholds : function(thresholds) {\n    this.thresholds = thresholds;\n  },\n\n  getWords : function(doc) {\n    if (_(doc).isArray()) {\n      return doc;\n    }\n    var words = doc.split(/\\W+/);\n    return _(words).uniq();\n  },\n\n  train : function(doc, cat, callback) {\n    this.incDocCounts([{doc: doc, cat: cat}], function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n    });\n  },\n\n  trainAll : function(data, callback) {\n    data = data.map(function(item) {\n      return {doc: item.input, cat: item.output};\n    });\n    this.incDocCounts(data, function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n    });\n  },\n\n  wordProb : function(word, cat, cats, counts) {\n    // times word appears in a doc in this cat / docs in this cat\n    var prob = (counts[cat] || 0) / cats[cat];\n\n    // get weighted average with assumed so prob won't be extreme on rare words\n    var total = _(cats).reduce(function(sum, p, cat) {\n      return sum + (counts[cat] || 0);\n    }, 0, this);\n    return (this.weight * this.assumed + total * prob) / (this.weight + total);\n  },\n\n  getCatProbs : function(cats, words, counts) {\n    var numDocs = _(cats).reduce(function(sum, count) {\n      return sum + count;\n    }, 0);\n\n    var probs = {};\n    _(cats).each(function(catCount, cat) {\n      var catProb = (catCount || 0) / numDocs;\n\n      var docProb = _(words).reduce(function(prob, word) {\n        var wordCounts = counts[word] || {};\n        return prob * this.wordProb(word, cat, cats, wordCounts);\n      }, 1, this);\n\n      // the probability this doc is in this category\n      probs[cat] = catProb * docProb;\n    }, this);\n    return probs;\n  },\n\n  getProbs : function(doc, callback) {\n    var that = this;\n    this.getCats(function(cats) {\n      var words = that.getWords(doc);\n      that.getWordCounts(words, cats, function(counts) {\n        var probs = that.getCatProbs(cats, words, counts);\n        callback(probs);\n      });\n    });\n  },\n\n  getProbsSync : function(doc) {\n    var words = this.getWords(doc);\n    var cats = this.getCats();\n    var counts = this.getWordCounts(words, cats);\n    return this.getCatProbs(cats, words, counts);\n  },\n\n  bestMatch : function(probs) {\n    var max = _(probs).reduce(function(max, prob, cat) {\n      return max.prob > prob ? max : {cat: cat, prob: prob};\n    }, {prob: 0});\n\n    var category = max.cat || this.default;\n    var threshold = this.thresholds[max.cat] || 1;\n\n    _(probs).map(function(prob, cat) {\n     if (!(cat == max.cat) && prob * threshold > max.prob) {\n       category = this.default; // not greater than other category by enough\n     }\n    }, this);\n\n    return category;\n  },\n\n  classify : function(doc, callback) {\n    if (!this.backend.async) {\n      return this.classifySync(doc);\n    }\n\n    var that = this;\n    this.getProbs(doc, function(probs) {\n      callback(that.bestMatch(probs));\n    });\n  },\n\n  classifySync : function(doc) {\n    var probs = this.getProbsSync(doc);\n    return this.bestMatch(probs);\n  },\n\n  test : function(data) {\n    // misclassification error\n    var error = 0;\n    data.forEach(function(datum) {\n      var output = this.classify(datum.input);\n      error += output == datum.output ? 0 : 1;\n    }, this);\n    return error / data.length;\n  },\n\n  toJSON : function(callback) {\n    return this.backend.toJSON(callback);\n  },\n\n  fromJSON : function(json, callback) {\n    this.backend.fromJSON(json, callback);\n    return this;\n  }\n}\n\nexports.Bayesian = Bayesian;\n\n});require.register(\"/underscore.js\", function(module, exports, require, global){\n//     Underscore.js 1.3.1\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.1';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      if (index == 0) {\n        shuffled[0] = value;\n      } else {\n        rand = Math.floor(Math.random() * (index + 1));\n        shuffled[index] = shuffled[rand];\n        shuffled[rand] = value;\n      }\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(iterable) {\n    if (!iterable)                return [];\n    if (iterable.toArray)         return iterable.toArray();\n    if (_.isArray(iterable))      return slice.call(iterable);\n    if (_.isArguments(iterable))  return slice.call(iterable);\n    return _.values(iterable);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.toArray(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head`. The **guard** check allows it to work\n  // with `_.map`.\n  _.first = _.head = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var result = [];\n    _.reduce(initial, function(memo, el, i) {\n      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) {\n        memo[memo.length] = el;\n        result[result.length] = array[i];\n      }\n      return memo;\n    }, []);\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(func, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds.\n  _.debounce = function(func, wait) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        func.apply(context, args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\'/g, \"'\");\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(str, data) {\n    var c  = _.templateSettings;\n    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +\n      'with(obj||{}){__p.push(\\'' +\n      str.replace(/\\\\/g, '\\\\\\\\')\n         .replace(/'/g, \"\\\\'\")\n         .replace(c.escape || noMatch, function(match, code) {\n           return \"',_.escape(\" + unescape(code) + \"),'\";\n         })\n         .replace(c.interpolate || noMatch, function(match, code) {\n           return \"',\" + unescape(code) + \",'\";\n         })\n         .replace(c.evaluate || noMatch, function(match, code) {\n           return \"');\" + unescape(code).replace(/[\\r\\n\\t]/g, ' ') + \";__p.push('\";\n         })\n         .replace(/\\r/g, '\\\\r')\n         .replace(/\\n/g, '\\\\n')\n         .replace(/\\t/g, '\\\\t')\n         + \"');}return __p.join('');\";\n    var func = new Function('obj', '_', tmpl);\n    if (data) return func(data, _);\n    return function(data) {\n      return func.call(this, data, _);\n    };\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);\n\n});classifier = require('bayesian.js');\n})();\n","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/index.js":"/* sanity tests for the browser */\n\nvar assert = {\n  fail : function(id) {\n    $(\"#\" + id + \" .fail\").addClass(\"true\");\n  },\n\n  pass : function(id) {\n    $(\"#\" + id + \" .pass\").addClass(\"true\");\n  },\n\n  ok : function(truth, message, id) {\n    if(!truth)\n      assert.fail(id);\n    else\n      assert.pass(id);\n  },\n  equal : function(a, b, message, id) {\n    if(a != b)\n      assert.fail(id);\n    else\n      assert.pass(id);\n  }\n};\n$(document).ready(function(){\n\n  (function testNeural() {\n    var wiggle = 0.1;\n\n    function testBitwise(data, op) {\n      var net = new classifier.NeuralNetwork();\n      net.train(data);\n\n      for(var i in data) {\n        var output = net.run(data[i].input);\n        var target = data[i].output;\n        assert.ok(output < (target + wiggle) && output > (target - wiggle),\n         \"failed to train \" + op + \" - output: \" + output + \" target: \" + target, \"nn-\" + op);\n      }\n    }\n\n    var and = [{input: [0, 0], output: [0]},\n               {input: [0, 1], output: [0]},\n               {input: [1, 0], output: [0]},\n               {input: [1, 1], output: [1]}];\n    testBitwise(and, \"and\");\n\n    var or = [{input: [0, 0], output: [0]},\n              {input: [0, 1], output: [1]},\n              {input: [1, 0], output: [1]},\n              {input: [1, 1], output: [1]}];\n    testBitwise(or, \"or\");\n  })();\n\n  (function testBayesian() {\n    function testBasic(bayes, id) {\n      var spam = [\"vicodin pharmacy\",\n                  \"all quality replica watches marked down\",\n                  \"cheap replica watches\",\n                  \"receive more traffic by gaining a higher ranking in search engines\",\n                  \"viagra pills\",\n                  \"watches chanel tag heuer\",\n                  \"watches at low prices\"];\n\n      var not = [\"unknown command line parameters\",\n                 \"I don't know if this works on Windows\",\n                 \"recently made changed to terms of service agreement\",\n                 \"does anyone know about this\",\n                 \"this is a bit out of date\",\n                 \"the startup options need linking\"]\n\n      spam.forEach(function(text) { bayes.train(text, 'spam'); });\n      not.forEach(function(text) { bayes.train(text, 'notspam'); });\n\n      assert.ok(\n        bayes.classify(\"replica watches\") == \"spam\" &&\n        bayes.classify(\"check out the docs\") == \"notspam\" &&\n        bayes.classify(\"recently, I've been thinking that I should\") == \"notspam\" &&\n        bayes.classify(\"come buy these cheap pills\") == \"spam\"\n      , \"bayes classification error\", id);\n    }\n\n    // test the synchronous backends\n    testBasic(new classifier.Bayesian(), \"bayes\");\n\n    testBasic(new classifier.Bayesian({\n      backend : {\n        type: 'localStorage',\n        options: {\n          name: 'testnamespace',\n          testing: true\n        }\n      }\n    }), \"bayes-localStorage\");\n  })();\n});","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/lib/classifier.js":"(function(){var global = this;function debug(){return debug};function require(p, parent){ var path = require.resolve(p) , mod = require.modules[path]; if (!mod) throw new Error('failed to require \"' + p + '\" from ' + parent); if (!mod.exports) { mod.exports = {}; mod.call(mod.exports, mod, mod.exports, require.relative(path), global); } return mod.exports;}require.modules = {};require.resolve = function(path){ var orig = path , reg = path + '.js' , index = path + '/index.js'; return require.modules[reg] && reg || require.modules[index] && index || orig;};require.register = function(path, fn){ require.modules[path] = fn;};require.relative = function(parent) { return function(p){ if ('debug' == p) return debug; if ('.' != p.charAt(0)) return require(p); var path = parent.split('/') , segs = p.split('/'); path.pop(); for (var i = 0; i < segs.length; i++) { var seg = segs[i]; if ('..' == seg) path.pop(); else if ('.' != seg) path.push(seg); } return require(path.join('/'), parent); };};require.register(\"backends/localStorage.js\", function(module, exports, require, global){\nvar _ = require(\"underscore\")._;\n\nvar LocalStorageBackend = function(options) {\n  var options = options || {};\n  var name = options.name || Math.floor(Math.random() * 100000);\n\n  this.prefix = 'classifier.bayesian.' + name;\n\n  if (options.testing) {\n    this.storage = {};\n  }\n  else {\n    this.storage = localStorage;\n  }\n\n  this.storage[this.prefix + '.cats'] = '{}';\n}\n\nLocalStorageBackend.prototype = {\n  async : false,\n\n  getCats : function() {\n    return JSON.parse(this.storage[this.prefix + '.cats']);\n  },\n\n  setCats : function(cats) {\n    this.storage[this.prefix + '.cats'] = JSON.stringify(cats);\n  },\n\n  getWordCount : function(word) {\n    return JSON.parse(this.storage[this.prefix + '.words.' + word] || '{}');\n  },\n\n  setWordCount : function(word, counts) {\n    this.storage[this.prefix + '.words.' + word] = JSON.stringify(counts);\n  },\n\n  getWordCounts : function(words) {\n    var counts = {};\n    words.forEach(function(word) {\n      counts[word] = this.getWordCount(word);\n    }, this);\n    return counts;\n  },\n\n  incCounts : function(catIncs, wordIncs) {\n    var cats = this.getCats();\n    _(catIncs).each(function(inc, cat) {\n      cats[cat] = cats[cat] + inc || inc;\n    }, this);\n    this.setCats(cats);\n\n    _(wordIncs).each(function(incs, word) {\n      var wordCounts = this.getWordCount(word);\n      _(incs).each(function(inc, cat) {\n        wordCounts[cat] = wordCounts[cat] + inc || inc;\n      }, this);\n      this.setWordCount(word, wordCounts);\n    }, this);\n  },\n\n  toJSON : function() {\n    var words = {};\n    var regex = new RegExp(\"^\" + this.prefix + \"\\.words\\.(.+)$\")\n    for (var item in this.storage) {\n      var match = regex.exec(item);\n      if (match) {\n        words[match[1]] = JSON.parse(this.storage[item]);\n      }\n    }\n    return {\n      cats: JSON.parse(this.storage[this.prefix + '.cats']),\n      words: words\n    };\n  },\n\n  fromJSON : function(json) {\n    this.incCounts(json.cats, json.words);\n  }\n}\n\nexports.LocalStorageBackend = LocalStorageBackend;\n});require.register(\"backends/memory.js\", function(module, exports, require, global){\nvar _ = require(\"underscore\")._;\n\nvar MemoryBackend = function() {\n  this.catCounts = {};\n  this.wordCounts = {};\n}\n\nMemoryBackend.prototype = {\n  async : false,\n\n  incCounts : function(catIncs, wordIncs) {\n    _(catIncs).each(function(inc, cat) {\n      this.catCounts[cat] = this.catCounts[cat] + inc || inc;\n    }, this);\n\n    _(wordIncs).each(function(incs, word) {\n      this.wordCounts[word] = this.wordCounts[word] || {};\n      _(incs).each(function(inc, cat) {\n        this.wordCounts[word][cat] = this.wordCounts[word][cat] + inc || inc;\n      }, this);\n    }, this);\n  },\n\n  getCats : function() {\n    return this.catCounts;\n  },\n\n  getWordCounts : function(words, cats) {\n    return this.wordCounts;\n  },\n  \n  toJSON : function() {\n    return {cats: this.catCounts, words: this.wordCounts}\n  },\n  \n  fromJSON : function(json) {\n    this.catCounts = json.cats;\n    this.wordCounts = json.words;\n  }\n}\n\nexports.MemoryBackend = MemoryBackend;\n});require.register(\"backends/redis.js\", function(module, exports, require, global){\nvar redis = require(\"redis\"),\n    _ = require(\"underscore\")._;\n\nvar RedisBackend = function(options) {\n  options = options || {};\n  var port = options.port || 6379;\n  var host = options.hostname || \"localhost\";\n  var opts = options.options || {};\n\n  this.client = function() {\n    var client = redis.createClient(port, host, opts);\n    if (options.error) {\n      client.on('error', options.error);\n    }\n    if (options.password) {\n      client.auth(options.password, options.error);\n    }\n    return client;\n  }\n\n  var name = options.name || Math.floor(Math.random() * 100000);\n  this.catsKey = 'classifier_bayes_cats_' + name;\n  this.wordsKey = 'classifier_bayes_words_' + name;\n\n  if (options.db) {\n    this.client().select(options.db);\n  }\n}\n\nRedisBackend.prototype = {\n  async : true,\n\n  key : function(word, cat) {\n    return word + \"____\" + cat; // flatten word count hash\n  },\n\n  pair : function(key) {\n    return /(.*)____(.*)/.exec(key).slice(1);\n  },\n\n  incCounts : function(catIncs, wordIncs, callback) {\n    // create new client for each call so we can close each time\n    var client = this.client();\n    var multi = client.multi(); // make multi so we can have one callback\n\n    _(catIncs).each(function(inc, cat) {\n      multi.hincrby(this.catsKey, cat, inc);\n    }, this);\n\n    _(wordIncs).each(function(wordCounts, word) {\n      _(wordCounts).each(function(inc, cat) {\n        multi.hincrby(this.wordsKey, this.key(word, cat), inc);\n      }, this);\n    }, this);\n\n    multi.exec(function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n      client.quit();\n    });\n  },\n\n  getCats : function(callback) {\n    var client = this.client();\n    client.hgetall(this.catsKey, function(err, cats) {\n      _(cats).each(function(val, cat) {\n        cats[cat] = parseInt(val);\n      });\n      callback(cats);\n      client.quit();\n    });\n  },\n\n  getWordCounts : function(words, cats, callback) {\n    var keys = _(words).reduce(function(keys, word) {\n       return keys.concat(_(cats).map(function(count, cat) {\n         return this.key(word, cat);\n       },this));\n    }, [], this);\n\n    var that = this;\n    var args = [this.wordsKey].concat(keys);\n    var client = this.client();\n\n    client.hmget(args, function(err, vals) {\n      var counts = {};\n      keys.map(function(key, i) {\n         var pair = that.pair(key);\n         var word = pair[0], cat = pair[1];\n         counts[word] = counts[word] ? counts[word] : {};\n         counts[word][cat] = parseInt(vals[i]) || 0;\n      });\n\n      callback(counts);\n      client.quit();\n    });\n  },\n\n  toJSON: function(callback) {\n    var that = this;\n    this.getCats(function(cats) {\n      var client = that.client();\n\n      client.hgetall(that.wordsKey, function(err, wordCounts) {\n        var words = {};\n        for (var key in wordCounts) {\n          var pair = that.pair(key);\n          var word = pair[0], cat = pair[1];\n          words[word] = words[word] ? words[word] : {};\n          words[word][cat] = parseInt(wordCounts[key]) || 0;\n        }\n\n        callback({cats: cats, words: words});\n        client.quit();\n      });\n    });\n  },\n\n  fromJSON: function(json, callback) {\n    this.incCounts(json.cats, json.words, callback);\n  }\n}\n\nexports.RedisBackend = RedisBackend;\n\n});require.register(\"bayesian.js\", function(module, exports, require, global){\nvar _ = require(\"underscore\")._;\n\nvar Bayesian = function(options) {\n  options = options || {}\n  this.thresholds = options.thresholds || {};\n  this.default = options.default || 'unclassified';\n  this.weight = options.weight || 1;\n  this.assumed = options.assumed || 0.5;\n\n  var backend = options.backend || { type: 'memory' };\n  switch(backend.type.toLowerCase()) {\n    case 'redis':\n      this.backend = new (require(\"./backends/redis\").RedisBackend)(backend.options);\n      break;\n    case 'localstorage':\n      this.backend = new (require(\"./backends/localStorage\")\n                     .LocalStorageBackend)(backend.options);\n      break;\n    default:\n      this.backend = new (require(\"./backends/memory\").MemoryBackend)();\n  }\n}\n\nBayesian.prototype = {\n  getCats : function(callback) {\n    return this.backend.getCats(callback);\n  },\n\n  getWordCounts : function(words, cats, callback) {\n    return this.backend.getWordCounts(words, cats, callback);\n  },\n\n  incDocCounts : function(docs, callback) {\n    // accumulate all the pending increments\n    var wordIncs = {};\n    var catIncs = {};\n    docs.forEach(function(doc) {\n      var cat = doc.cat;\n      catIncs[cat] = catIncs[cat] ? catIncs[cat] + 1 : 1;\n\n      var words = this.getWords(doc.doc);\n      words.forEach(function(word) {\n        wordIncs[word] = wordIncs[word] || {};\n        wordIncs[word][cat] = wordIncs[word][cat] ? wordIncs[word][cat] + 1 : 1;\n      }, this);\n    }, this);\n\n    return this.backend.incCounts(catIncs, wordIncs, callback);\n  },\n\n  setThresholds : function(thresholds) {\n    this.thresholds = thresholds;\n  },\n\n  getWords : function(doc) {\n    if (_(doc).isArray()) {\n      return doc;\n    }\n    var words = doc.split(/\\W+/);\n    return _(words).uniq();\n  },\n\n  train : function(doc, cat, callback) {\n    this.incDocCounts([{doc: doc, cat: cat}], function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n    });\n  },\n\n  trainAll : function(data, callback) {\n    data = data.map(function(item) {\n      return {doc: item.input, cat: item.output};\n    });\n    this.incDocCounts(data, function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n    });\n  },\n\n  wordProb : function(word, cat, cats, counts) {\n    // times word appears in a doc in this cat / docs in this cat\n    var prob = (counts[cat] || 0) / cats[cat];\n\n    // get weighted average with assumed so prob won't be extreme on rare words\n    var total = _(cats).reduce(function(sum, p, cat) {\n      return sum + (counts[cat] || 0);\n    }, 0, this);\n    return (this.weight * this.assumed + total * prob) / (this.weight + total);\n  },\n\n  getCatProbs : function(cats, words, counts) {\n    var numDocs = _(cats).reduce(function(sum, count) {\n      return sum + count;\n    }, 0);\n\n    var probs = {};\n    _(cats).each(function(catCount, cat) {\n      var catProb = (catCount || 0) / numDocs;\n\n      var docProb = _(words).reduce(function(prob, word) {\n        var wordCounts = counts[word] || {};\n        return prob * this.wordProb(word, cat, cats, wordCounts);\n      }, 1, this);\n\n      // the probability this doc is in this category\n      probs[cat] = catProb * docProb;\n    }, this);\n    return probs;\n  },\n\n  getProbs : function(doc, callback) {\n    var that = this;\n    this.getCats(function(cats) {\n      var words = that.getWords(doc);\n      that.getWordCounts(words, cats, function(counts) {\n        var probs = that.getCatProbs(cats, words, counts);\n        callback(probs);\n      });\n    });\n  },\n\n  getProbsSync : function(doc) {\n    var words = this.getWords(doc);\n    var cats = this.getCats();\n    var counts = this.getWordCounts(words, cats);\n    return this.getCatProbs(cats, words, counts);\n  },\n\n  bestMatch : function(probs) {\n    var max = _(probs).reduce(function(max, prob, cat) {\n      return max.prob > prob ? max : {cat: cat, prob: prob};\n    }, {prob: 0});\n\n    var category = max.cat || this.default;\n    var threshold = this.thresholds[max.cat] || 1;\n\n    _(probs).map(function(prob, cat) {\n     if (!(cat == max.cat) && prob * threshold > max.prob) {\n       category = this.default; // not greater than other category by enough\n     }\n    }, this);\n\n    return category;\n  },\n\n  classify : function(doc, callback) {\n    if (!this.backend.async) {\n      return this.classifySync(doc);\n    }\n\n    var that = this;\n    this.getProbs(doc, function(probs) {\n      callback(that.bestMatch(probs));\n    });\n  },\n\n  classifySync : function(doc) {\n    var probs = this.getProbsSync(doc);\n    return this.bestMatch(probs);\n  },\n\n  test : function(data) {\n    // misclassification error\n    var error = 0;\n    data.forEach(function(datum) {\n      var output = this.classify(datum.input);\n      error += output == datum.output ? 0 : 1;\n    }, this);\n    return error / data.length;\n  },\n\n  toJSON : function(callback) {\n    return this.backend.toJSON(callback);\n  },\n\n  fromJSON : function(json, callback) {\n    this.backend.fromJSON(json, callback);\n    return this;\n  }\n}\n\nexports.Bayesian = Bayesian;\n\n});require.register(\"classifier.js\", function(module, exports, require, global){\n\n});require.register(\"underscore\", function(module, exports, require, global){\n//     Underscore.js 1.3.1\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.1';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      if (index == 0) {\n        shuffled[0] = value;\n      } else {\n        rand = Math.floor(Math.random() * (index + 1));\n        shuffled[index] = shuffled[rand];\n        shuffled[rand] = value;\n      }\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(iterable) {\n    if (!iterable)                return [];\n    if (iterable.toArray)         return iterable.toArray();\n    if (_.isArray(iterable))      return slice.call(iterable);\n    if (_.isArguments(iterable))  return slice.call(iterable);\n    return _.values(iterable);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.toArray(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head`. The **guard** check allows it to work\n  // with `_.map`.\n  _.first = _.head = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var result = [];\n    _.reduce(initial, function(memo, el, i) {\n      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) {\n        memo[memo.length] = el;\n        result[result.length] = array[i];\n      }\n      return memo;\n    }, []);\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(func, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds.\n  _.debounce = function(func, wait) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        func.apply(context, args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\'/g, \"'\");\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(str, data) {\n    var c  = _.templateSettings;\n    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +\n      'with(obj||{}){__p.push(\\'' +\n      str.replace(/\\\\/g, '\\\\\\\\')\n         .replace(/'/g, \"\\\\'\")\n         .replace(c.escape || noMatch, function(match, code) {\n           return \"',_.escape(\" + unescape(code) + \"),'\";\n         })\n         .replace(c.interpolate || noMatch, function(match, code) {\n           return \"',\" + unescape(code) + \",'\";\n         })\n         .replace(c.evaluate || noMatch, function(match, code) {\n           return \"');\" + unescape(code).replace(/[\\r\\n\\t]/g, ' ') + \";__p.push('\";\n         })\n         .replace(/\\r/g, '\\\\r')\n         .replace(/\\n/g, '\\\\n')\n         .replace(/\\t/g, '\\\\t')\n         + \"');}return __p.join('');\";\n    var func = new Function('obj', '_', tmpl);\n    if (data) return func(data, _);\n    return function(data) {\n      return func.call(this, data, _);\n    };\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);\n\n});classifier = require('bayesian.js');\n})();\n","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/lib/backends/localStorage.js":"var _ = require(\"underscore\")._;\n\nvar LocalStorageBackend = function(options) {\n  var options = options || {};\n  var name = options.name || Math.floor(Math.random() * 100000);\n\n  this.prefix = 'classifier.bayesian.' + name;\n\n  if (options.testing) {\n    this.storage = {};\n  }\n  else {\n    this.storage = localStorage;\n  }\n\n  this.storage[this.prefix + '.cats'] = '{}';\n}\n\nLocalStorageBackend.prototype = {\n  async : false,\n\n  getCats : function() {\n    return JSON.parse(this.storage[this.prefix + '.cats']);\n  },\n\n  setCats : function(cats) {\n    this.storage[this.prefix + '.cats'] = JSON.stringify(cats);\n  },\n\n  getWordCount : function(word) {\n    return JSON.parse(this.storage[this.prefix + '.words.' + word] || '{}');\n  },\n\n  setWordCount : function(word, counts) {\n    this.storage[this.prefix + '.words.' + word] = JSON.stringify(counts);\n  },\n\n  getWordCounts : function(words) {\n    var counts = {};\n    words.forEach(function(word) {\n      counts[word] = this.getWordCount(word);\n    }, this);\n    return counts;\n  },\n\n  incCounts : function(catIncs, wordIncs) {\n    var cats = this.getCats();\n    _(catIncs).each(function(inc, cat) {\n      cats[cat] = cats[cat] + inc || inc;\n    }, this);\n    this.setCats(cats);\n\n    _(wordIncs).each(function(incs, word) {\n      var wordCounts = this.getWordCount(word);\n      _(incs).each(function(inc, cat) {\n        wordCounts[cat] = wordCounts[cat] + inc || inc;\n      }, this);\n      this.setWordCount(word, wordCounts);\n    }, this);\n  },\n\n  toJSON : function() {\n    var words = {};\n    var regex = new RegExp(\"^\" + this.prefix + \"\\.words\\.(.+)$\")\n    for (var item in this.storage) {\n      var match = regex.exec(item);\n      if (match) {\n        words[match[1]] = JSON.parse(this.storage[item]);\n      }\n    }\n    return {\n      cats: JSON.parse(this.storage[this.prefix + '.cats']),\n      words: words\n    };\n  },\n\n  fromJSON : function(json) {\n    this.incCounts(json.cats, json.words);\n  }\n}\n\nexports.LocalStorageBackend = LocalStorageBackend;","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/lib/backends/memory.js":"var _ = require(\"underscore\")._;\n\nvar MemoryBackend = function() {\n  this.catCounts = {};\n  this.wordCounts = {};\n}\n\nMemoryBackend.prototype = {\n  async : false,\n\n  incCounts : function(catIncs, wordIncs) {\n    _(catIncs).each(function(inc, cat) {\n      this.catCounts[cat] = this.catCounts[cat] + inc || inc;\n    }, this);\n\n    _(wordIncs).each(function(incs, word) {\n      this.wordCounts[word] = this.wordCounts[word] || {};\n      _(incs).each(function(inc, cat) {\n        this.wordCounts[word][cat] = this.wordCounts[word][cat] + inc || inc;\n      }, this);\n    }, this);\n  },\n\n  getCats : function() {\n    return this.catCounts;\n  },\n\n  getWordCounts : function(words, cats) {\n    return this.wordCounts;\n  },\n  \n  toJSON : function() {\n    return {cats: this.catCounts, words: this.wordCounts}\n  },\n  \n  fromJSON : function(json) {\n    this.catCounts = json.cats;\n    this.wordCounts = json.words;\n  }\n}\n\nexports.MemoryBackend = MemoryBackend;","/home/travis/build/npmtest/node-npmtest-classifier/node_modules/classifier/lib/backends/redis.js":"var redis = require(\"redis\"),\n    _ = require(\"underscore\")._;\n\nvar RedisBackend = function(options) {\n  options = options || {};\n  var port = options.port || 6379;\n  var host = options.hostname || \"localhost\";\n  var opts = options.options || {};\n\n  this.client = function() {\n    var client = redis.createClient(port, host, opts);\n    if (options.error) {\n      client.on('error', options.error);\n    }\n    if (options.password) {\n      client.auth(options.password, options.error);\n    }\n    return client;\n  }\n\n  var name = options.name || Math.floor(Math.random() * 100000);\n  this.catsKey = 'classifier_bayes_cats_' + name;\n  this.wordsKey = 'classifier_bayes_words_' + name;\n\n  if (options.db) {\n    this.client().select(options.db);\n  }\n}\n\nRedisBackend.prototype = {\n  async : true,\n\n  key : function(word, cat) {\n    return word + \"____\" + cat; // flatten word count hash\n  },\n\n  pair : function(key) {\n    return /(.*)____(.*)/.exec(key).slice(1);\n  },\n\n  incCounts : function(catIncs, wordIncs, callback) {\n    // create new client for each call so we can close each time\n    var client = this.client();\n    var multi = client.multi(); // make multi so we can have one callback\n\n    _(catIncs).each(function(inc, cat) {\n      multi.hincrby(this.catsKey, cat, inc);\n    }, this);\n\n    _(wordIncs).each(function(wordCounts, word) {\n      _(wordCounts).each(function(inc, cat) {\n        multi.hincrby(this.wordsKey, this.key(word, cat), inc);\n      }, this);\n    }, this);\n\n    multi.exec(function(err, ret) {\n      if (callback) {\n        callback(ret);\n      }\n      client.quit();\n    });\n  },\n\n  getCats : function(callback) {\n    var client = this.client();\n    client.hgetall(this.catsKey, function(err, cats) {\n      _(cats).each(function(val, cat) {\n        cats[cat] = parseInt(val);\n      });\n      callback(cats);\n      client.quit();\n    });\n  },\n\n  getWordCounts : function(words, cats, callback) {\n    var keys = _(words).reduce(function(keys, word) {\n       return keys.concat(_(cats).map(function(count, cat) {\n         return this.key(word, cat);\n       },this));\n    }, [], this);\n\n    var that = this;\n    var args = [this.wordsKey].concat(keys);\n    var client = this.client();\n\n    client.hmget(args, function(err, vals) {\n      var counts = {};\n      keys.map(function(key, i) {\n         var pair = that.pair(key);\n         var word = pair[0], cat = pair[1];\n         counts[word] = counts[word] ? counts[word] : {};\n         counts[word][cat] = parseInt(vals[i]) || 0;\n      });\n\n      callback(counts);\n      client.quit();\n    });\n  },\n\n  toJSON: function(callback) {\n    var that = this;\n    this.getCats(function(cats) {\n      var client = that.client();\n\n      client.hgetall(that.wordsKey, function(err, wordCounts) {\n        var words = {};\n        for (var key in wordCounts) {\n          var pair = that.pair(key);\n          var word = pair[0], cat = pair[1];\n          words[word] = words[word] ? words[word] : {};\n          words[word][cat] = parseInt(wordCounts[key]) || 0;\n        }\n\n        callback({cats: cats, words: words});\n        client.quit();\n      });\n    });\n  },\n\n  fromJSON: function(json, callback) {\n    this.incCounts(json.cats, json.words, callback);\n  }\n}\n\nexports.RedisBackend = RedisBackend;\n"}